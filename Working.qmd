---
title: "EDA WORK"
format: 
 html:
    fig-height: 4
    fig-width: 6
---

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
```

Move amb 4 from south to north - Sonya -when we move from south to north

```{r}
load("emsData.RData")
```

```{r}

#don't remove central, fix this.
#we are assuming that we are only looking at causes in south and north then

#this is why i removed central because this option means that is separate
x |>
  select(eTT.BG.So, eTT.BG.NN, eTT.BG.FN, REF.GRID) |> 
  filter(REF.GRID != "2 Central") |>
  select(-REF.GRID) |>
  pivot_longer(cols = everything(),
               names_to = "source",
               values_to = "value") |> 
  ggplot(aes(x = source, y = value)) +
  geom_boxplot() +
  labs(
    x = "Source",
    y = "eTT.BG Value",
    title = "Distribution of eTT.BG by Source"
  ) +
  theme_minimal()

```

we lose something though. if we have something there, we lose something. We somehow end up putting it below hand.
```{r}
library(lubridate)

x<- x %>%
  mutate(
    disp_hour = hour(DT.DISP),
    disp_min  = minute(DT.DISP),
    rush_hour = !is.na(DT.DISP) & (
      
      #morning 7:30pm - 9:30am
      (disp_hour == 7 & disp_min >= 30) |
      (disp_hour == 8) |
      (disp_hour == 9 & disp_min < 30) |
      
      #evening 4:00pm - 6:30pm
      (disp_hour == 16) |
      (disp_hour == 17) |
      (disp_hour == 18 & disp_min < 30)
    ),
    # 1 if rush hour 0 else
    rush_hour_ind = as.integer(rush_hour)  
  ) %>%
  select(-disp_hour, -disp_min)
```







```{r}

time = cbind(x$eTT.BG.NN, x$eTT.BG.FN, x$eTT.BG.So)


x %>%
  select(eTT.BG.NN, eTT.BG.FN, eTT.BG.So) %>%
  pivot_longer(cols = everything(),
               names_to = "source",
               values_to = "time") %>%
  ggplot(aes(x = time, color = source)) +
  geom_density(linewidth = 1.2) +
  labs(
    x = "Time",
    y = "Density",
    title = "Distribution of eTT.BG Values (All Sources)"
  ) +
  theme_minimal()


```

```{r}
x %>%
  filter(REF.GRID != "2 CENTRAL") %>%
  select(eTT.BG.NN, eTT.BG.FN, eTT.BG.So) %>%
  pivot_longer(cols = everything(),
               names_to = "source",
               values_to = "time") %>%
  ggplot(aes(x = time, color = source)) +
  geom_density(linewidth = 1.2) +
  labs(
    x = "Time",
    y = "Density",
    title = "Distribution of eTT.BG Values (All Sources)"
  ) +
  theme_minimal()
```

```{r}

x %>%
  filter(REF.GRID != "2 Central") %>%
  mutate(REF.GRID = as.factor(REF.GRID)) %>%
  pivot_longer(
    cols = c(eTT.BG.NN, eTT.BG.FN, eTT.BG.So),  # pivot only numeric time columns
    names_to = "source",
    values_to = "time"
  ) %>%
  ggplot(aes(x = time, color = source)) +
  geom_density(linewidth = 1.2) +
  labs(
    x = "Time",
    y = "Density",
    title = "Distribution of eTT.BG Values (All Sources)"
  ) +
  theme_minimal() +
  facet_wrap(~REF.GRID)
```

Quantify this, make it into words

## Mixed Effect

```{r}
library(dplyr)
library(tidyr)

x_long <- x %>%
  pivot_longer(
    cols = c(starts_with("Dist."), starts_with("eTT.")),
    names_to = c(".value", "Destination"),
    names_pattern = "(.*)\\.(So|Ce|NN|FN)$"
  )

```

```{r}
library(dplyr)
library(tidyr)
library(stringr)

x_expanded <- x %>%
  # create a unique ID per original row
  mutate(CallID = row_number()) %>%
  
  # repeat rows for 5 scenarios
  tidyr::uncount(weights = 5, .id = "scenario_id") %>%
  mutate(
    Scenario = paste0("S", scenario_id - 1),
    
    # extract call location from REF.GRID
    CallLoc = str_extract(REF.GRID, "(South|Central|North)"),
    # normalize to codes
    CallLocCode = case_when(
      CallLoc == "South"   ~ "So",
      CallLoc == "Central" ~ "Ce",
      CallLoc == "North"   ~ "NN"  # treat all "North" as "NN"
    ),
    
    # dispatch rules
    Dispatch = case_when(
      # S0
      Scenario == "S0" & CallLocCode == "NN" ~ "Ce",
      Scenario == "S0" & CallLocCode == "Ce" ~ "Ce",
      Scenario == "S0" & CallLocCode == "So" ~ "So",
      
      # S1
      Scenario == "S1" & CallLocCode == "NN" ~ "NN",
      Scenario == "S1" & CallLocCode == "Ce" ~ "Ce",
      Scenario == "S1" & CallLocCode == "So" ~ "Ce",
      
      # S2
      Scenario == "S2" & CallLocCode == "NN" ~ "FN",
      Scenario == "S2" & CallLocCode == "Ce" ~ "Ce",
      Scenario == "S2" & CallLocCode == "So" ~ "Ce",
      
      # S3
      Scenario == "S3" & CallLocCode == "NN" ~ "NN",
      Scenario == "S3" & CallLocCode == "Ce" ~ "Ce",
      Scenario == "S3" & CallLocCode == "So" ~ "So",
      
      # S4
      Scenario == "S4" & CallLocCode == "NN" ~ "FN",
      Scenario == "S4" & CallLocCode == "Ce" ~ "Ce",
      Scenario == "S4" & CallLocCode == "So" ~ "So"
    ),
    
    # pick the correct estimated travel time
    EstTravelTime = case_when(
      Dispatch == "So" ~ eTT.BG.So,
      Dispatch == "Ce" ~ eTT.BG.Ce,
      Dispatch == "NN" ~ eTT.BG.NN,
      Dispatch == "FN" ~ eTT.BG.FN
    )
  ) %>%
  select(-scenario_id)


```


## Modeling

```{r}
library(lme4)
library(broom.mixed)
library(ggplot2)
library(dplyr)

# Store formula as a string for annotation
formula_latex <- "EstTravelTime ~ Scenario + (1 | CallID)"

# Fit the model
m <- lmer(EstTravelTime ~ Scenario + (1 | CallID), data = x_expanded)

# Extract fixed effects, exclude intercept
coefs <- broom.mixed::tidy(m, effects = "fixed", conf.int = TRUE) %>%
  filter(term != "(Intercept)") %>%
  mutate(Significant = !(conf.low <= 0 & conf.high >= 0))

# Plot
ggplot(coefs, aes(x = term, y = estimate, color = Significant)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
  scale_color_manual(values = c("grey60", "steelblue")) +
  coord_flip() +
  labs(x = "", y = "Coefficient estimate",
       title = "Fixed effects (significant ones highlighted)") +
  theme_minimal()
  # Add the formula as text on the plot (top right)

```
```{r}
# Extract fitted values and residuals
x_expanded$fitted <- fitted(m)
x_expanded$resid <- resid(m)

# 1. Residuals vs fitted values
ggplot(x_expanded, aes(x = fitted, y = resid)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(x = "Fitted Values", y = "Residuals",
       title = "Residuals vs Fitted Values")

# 2. Residuals across the categorical variable
ggplot(x_expanded, aes(x = DISPATCH.PRIORITY.NAME, y = resid)) +
  geom_boxplot() +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(x = "Dispatch Priority", y = "Residuals",
       title = "Residuals by Dispatch Priority")
```

```{r}
library(nlme)

x_clean <- x_expanded %>%
  filter(!is.na(EstTravelTime),
         !is.na(Scenario),
         !is.na(REC.LON),
         !is.na(REC.LAT))
# Simple lme with residual variance as function of lon/lat
m2 <- lme(EstTravelTime ~ Scenario,
             random = ~1 | CallID,
             weights = varFixed(~ REC.LON + REC.LAT),
             data = x_clean,
             method = "REML")


#varident potentially. Var power and var constant power, deepdne on fitted valeus

```



```{r}
m2
```



```{r}
resid_m <- residuals(m2, type = "pearson")

# Residuals vs predicted
plot(fitted(m2), resid_m, main="Residuals vs Fitted")
abline(h=0, col="red")

# Residuals vs coordinates
plot(x_clean$REC.LON, resid_m, main="Residuals vs Longitude")
plot(x_clean$REC.LAT, resid_m, main="Residuals vs Latitude")

# Histogram
hist(resid_m, breaks=30, main="Histogram of normalized residuals")

```

```{r}
library(lme4)

# Suppose your spatial variable is called `SpatialID` (already discrete)
# Original model:
# m <- lmer(EstTravelTime ~ Scenario + (1 | CallID), data = x_clean)

# Add spatial random effect:
m_spatial <- lmer(EstTravelTime ~ Scenario + (1 | CallID) + (1 | REC.LON) +(1|REC.LAT),
                  data = x_clean)

# Examine results
summary(m_spatial)

```

```{r}
resid_m <- residuals(m_spatial)
plot(fitted(m_spatial), resid_m)
hist(resid_m, breaks=30)

```


```{r}
# Combine LON and LAT into a single factor
x_clean$SpatialID <- interaction(x_clean$REC.LON, x_clean$REC.LAT)

x_expanded <- x_expanded %>%
  mutate(Distance = case_when(
    Dispatch == "So" ~ Dist.So,
    Dispatch == "Ce" ~ Dist.Ce,
    Dispatch == "NN" ~ Dist.NN,
    Dispatch == "FN" ~ Dist.FN
  ))

# Fit model
library(lme4)
m_spatial <- lmer(EstTravelTime ~ Scenario + (1 | CallID) + (1 | SpatialID),
                  data = x_clean)

```


```{r}
yo <- x |>
  filter(REF.GRID == "3 South")

library(dplyr)
library(lubridate)

# Assuming your data is called df
# Convert columns to POSIXct
df <- yo %>%
  mutate(
    DT.DISP = ymd_hms(DT.DISP),
    DT.ENROUTE = ymd_hms(DT.ENROUTE),
    DT.AVAILABLE = ymd_hms(DT.AVAILABLE)
  )

# Find conflicts where AVAILABLE is after DISP
conflicts <- df %>%
  filter(DT.AVAILABLE > DT.DISP)

# View conflicts
print(conflicts)

```

```{r}
library(dplyr)
library(lubridate)

conflicts <- df %>%
  filter(DT.AVAILABLE > DT.DISP) %>%
  mutate(
    conflict_minutes = as.numeric(difftime(DT.AVAILABLE, DT.DISP, units = "mins"))
  )

library(ggplot2)

ggplot(conflicts, aes(x = conflict_minutes)) +
  geom_histogram(binwidth = 5, fill = "steelblue", color = "white") +
  labs(title = "Conflict Duration Distribution",
       x = "Conflict Duration (minutes)",
       y = "Count") +
  theme_minimal()


```

```{r}
ro <- x |>
  filter(REF.GRID != "3 South")

library(dplyr)
library(lubridate)

# Assuming your data is called df
# Convert columns to POSIXct
df2 <- ro %>%
  mutate(
    DT.DISP = ymd_hms(DT.DISP),
    DT.ENROUTE = ymd_hms(DT.ENROUTE),
    DT.AVAILABLE = ymd_hms(DT.AVAILABLE)
  )

conflicts <- df2 %>%
  filter(DT.AVAILABLE > DT.DISP) %>%
  mutate(
    conflict_minutes = as.numeric(difftime(DT.AVAILABLE, DT.DISP, units = "mins"))
  )
  
if (!requireNamespace("IRanges", quietly = TRUE)) {
  install.packages("BiocManager")
  BiocManager::install("IRanges")
}
library(IRanges)
library(dplyr)
library(lubridate)
library(IRanges)

# Assume conflicts already has DT.DISP and DT.AVAILABLE
intervals <- IRanges(start = as.numeric(conflicts$DT.DISP),
                     end = as.numeric(conflicts$DT.AVAILABLE))

# Count how many intervals overlap at each start
overlap_counts <- countOverlaps(intervals, intervals)

# Filter rows where there are at least 3 overlapping intervals
conflicts_3plus <- conflicts[overlap_counts >= 3, ]

```

```{r}

# Add overlap info to dataframe
conflicts <- conflicts %>%
  mutate(overlap_count = overlap_counts,
         overlap_level = ifelse(overlap_count >= 3, "3+ conflicts", "1-2 conflicts"))

ggplot(conflicts, aes(x = DT.DISP, xend = DT.AVAILABLE, y = 1, yend = 1, color = overlap_level)) +
  geom_segment(size = 3) +
  scale_color_manual(values = c("1-2 conflicts" = "blue", "3+ conflicts" = "red")) +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(title = "Timeline of Load Conflicts",
       x = "Time",
       color = "Conflict Level") +
  theme_minimal() +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())


```

```{r}

ggplot(conflicts, aes(x = conflict_minutes)) +
  geom_histogram(binwidth = 5, fill = "steelblue", color = "white") +
  labs(title = "Conflict Duration Distribution",
       x = "Conflict Duration (minutes)",
       y = "Count") +
  theme_minimal()
```




```{r}
# Fit the model

x_expanded <- x_expanded %>%
  mutate(Distance = case_when(
    Dispatch == "So" ~ Dist.So,
    Dispatch == "Ce" ~ Dist.Ce,
    Dispatch == "NN" ~ Dist.NN,
    Dispatch == "FN" ~ Dist.FN
  ))
mz <- lmer(EstTravelTime ~ Scenario + Distance + rush_hour_ind +(1 | CallID), data = x_expanded)
```
```{r}
# Extract residuals
resid_mz <- resid(mz)

# Create a QQ plot using ggplot2
qqplot_df <- data.frame(residuals = resid_mz)

ggplot(qqplot_df, aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(title = "QQ Plot of Residuals",
       x = "Theoretical Quantiles",
       y = "Sample Residuals") +
      coord_cartesian(ylim = c(min(resid_mz), 100)) +  # set max y to 100
  theme_minimal()

fitted_m2 <- fitted(mz)
resid_m2 <- resid(mz, type = "pearson")  # normalized residuals recommended for lme

# Create a data frame for plotting
resid_df <- data.frame(fitted = fitted_m2, residuals = resid_m2)

# Plot residuals vs fitted
ggplot(resid_df, aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.5) +       # scatter points
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") + # reference line at 0
  labs(title = "Residuals vs Fitted Values",
       x = "Fitted Values",
       y = "Pearson Residuals") +
  theme_minimal()
```

```{r}
mz_log <- lmer(log(EstTravelTime) ~ Scenario + Distance + rush_hour_ind +(1 | CallID), data = x_expanded)

# Extract residuals
resid_mz <- resid(mz_log)

# Create a QQ plot using ggplot2
qqplot_df <- data.frame(residuals = resid_mz)

ggplot(qqplot_df, aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(title = "QQ Plot of Residuals",
       x = "Theoretical Quantiles",
       y = "Sample Residuals") +
      coord_cartesian(ylim = c(min(resid_mz), 100)) +  # set max y to 100
  theme_minimal()

fitted_m2 <- fitted(mz)
resid_m2 <- resid(mz, type = "pearson")  # normalized residuals recommended for lme

# Create a data frame for plotting
resid_df <- data.frame(fitted = fitted_m2, residuals = resid_m2)

# Plot residuals vs fitted
ggplot(resid_df, aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.5) +       # scatter points
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") + # reference line at 0
  labs(title = "Residuals vs Fitted Values",
       x = "Fitted Values",
       y = "Pearson Residuals") +
  theme_minimal()
```

```{r}
library(sjPlot)
tab_model(mz_log,
          show.re.var = TRUE,      # show random effect variance
          show.icc = TRUE,         # show intraclass correlation
          show.se = TRUE,          # show standard errors
          transform = NULL,        # already log-transformed
          title = "Linear Mixed Model for log(EstTravelTime)")
```



```{r}
m2 <- lme(EstTravelTime ~  Scenario + Distance + rush_hour_ind,
             random = ~1 | CallID,
             weights = varFixed(~ Distance),
             data = x_expanded,
             method = "REML")

resid_m2 <- resid(m2, type = "pearson")  # normalized residuals are standard for QQ plots

# Create QQ plot using ggplot2
qqplot_df <- data.frame(residuals = resid_m2)

ggplot(qqplot_df, aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(title = "QQ Plot of Residuals for lme Model",
       x = "Theoretical Quantiles",
       y = "Sample Residuals") +
    coord_cartesian(ylim = c(min(resid_m2), 100)) +  # set max y to 100
  theme_minimal()

fitted_m2 <- fitted(m2)
resid_m2 <- resid(m2, type = "pearson")  # normalized residuals recommended for lme

# Create a data frame for plotting
resid_df <- data.frame(fitted = fitted_m2, residuals = resid_m2)

# Plot residuals vs fitted
ggplot(resid_df, aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.5) +       # scatter points
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") + # reference line at 0
  labs(title = "Residuals vs Fitted Values",
       x = "Fitted Values",
       y = "Pearson Residuals") +
  theme_minimal()
```

```{r}
m2
```



```{r}
m2log <- lme(EstTravelTime ~  Scenario + Distance + rush_hour_ind,
             random = ~1 | CallID,
             weights = varFixed(~ Distance),
             data = x_expanded,
             method = "REML")

resid_m2 <- resid(m2log, type = "pearson")  # normalized residuals are standard for QQ plots

# Create QQ plot using ggplot2
qqplot_df <- data.frame(residuals = resid_m2)

ggplot(qqplot_df, aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(title = "QQ Plot of Residuals for lme Model",
       x = "Theoretical Quantiles",
       y = "Sample Residuals") +
      coord_cartesian(ylim = c(min(resid_m2), 100)) +  # set max y to 100
  theme_minimal()

fitted_m2 <- fitted(m2)
resid_m2 <- resid(m2, type = "pearson")  # normalized residuals recommended for lme

# Create a data frame for plotting
resid_df <- data.frame(fitted = fitted_m2, residuals = resid_m2)

# Plot residuals vs fitted
ggplot(resid_df, aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.5) +       # scatter points
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") + # reference line at 0
  labs(title = "Residuals vs Fitted Values",
       x = "Fitted Values",
       y = "Pearson Residuals") +
  theme_minimal()
```


## Future steps 
#do normalized residuals instead 

#look at the estimates that will show if we are having estimates

#also do comparison across the covariates


```{r}
x_filtered <- x_expanded %>%
  group_by(CallID) %>%
  filter(var(EstTravelTime, na.rm = TRUE) > 0) %>%
  ungroup()

```
```{r}
library(lme4)

mz_filtered <- lmer(
  EstTravelTime ~ Scenario + Distance + rush_hour_ind + (1 | CallID),
  data = x_filtered
)

```

```{r}
mz_log_filtered <- lmer(
  log(EstTravelTime) ~ Scenario + Distance + rush_hour_ind + (1 | CallID),
  data = x_filtered
)

```
```{r}
# Extract residuals and fitted values
resid_filtered <- resid(mz_filtered)
fitted_filtered <- fitted(mz_filtered)

# Residuals vs Fitted
ggplot(data.frame(fitted = fitted_filtered, residuals = resid_filtered),
       aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuals vs Fitted (No-Change Calls Removed)",
       x = "Fitted Values", y = "Residuals") +
  theme_minimal()

# QQ plot
ggplot(data.frame(residuals = resid_filtered), aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(title = "QQ Plot of Residuals (No-Change Calls Removed)",
       x = "Theoretical Quantiles", y = "Sample Residuals") +
  theme_minimal()

```

```{r}
library(nlme)

m_varident <- lme(
  EstTravelTime ~ Scenario + Distance + rush_hour_ind,
  random = ~1 | CallID,
  weights = varIdent(form = ~1 | Scenario),
  data = x_filtered,
  method = "REML"
)

```

```{r}
# Extract normalized residuals (Pearson) and fitted values
resid_vi <- resid(m_varident, type = "pearson")
fitted_vi <- fitted(m_varident)

# Residuals vs fitted
library(ggplot2)

ggplot(data.frame(fitted = fitted_vi, residuals = resid_vi),
       aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuals vs Fitted (varIdent by Scenario)",
       x = "Fitted Values", y = "Pearson Residuals") +
  theme_minimal()

# QQ plot
ggplot(data.frame(residuals = resid_vi), aes(sample = residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(title = "QQ Plot of Residuals (varIdent Model)",
       x = "Theoretical Quantiles", y = "Sample Residuals") +
  theme_minimal()

# Histogram
ggplot(data.frame(residuals = resid_vi), aes(x = residuals)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Histogram of Residuals (varIdent Model)",
       x = "Pearson Residuals", y = "Count") +
  theme_minimal()

```

